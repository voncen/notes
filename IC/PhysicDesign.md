

# 芯片设计全流程
重点知识：你必须像背诵乘法口诀一样熟悉从行为描述到GDSII的每一个步骤，包括每个步骤的输入、输出、目的和主流工具。
主流：自顶向下： 前端从系统设计到门级网表，后端从晶体管到GDSII


## 前端设计

1. RTL设计：HDL描述电路功能，定义寄存器传输级的数据流动以及如何被组合逻辑处理。OUTPUT: RTL代码
   1. 非阻塞赋值：在当前仿真时间步长（time step）的结束时刻统一完成赋值操作。所有右侧表达式的计算是并行的，使用的是该时间步长开始时的原始值
   2. 避免生成锁存器： 在组合逻辑中，如果条件语句（if/case）分支不全，或赋值不完整，会综合出非预期的锁存器。确保所有条件下输出都有明确赋值。
2. 功能验证（前仿）确保RTL代码逻辑正确。工具：VCS, NC-Verilog, ModelSim。OUTPUT: 逻辑验证结果
3. 逻辑综合： 将RTL代码映射到特定工艺库的门级网表。输入：RTL代码、工艺库(.lib)、约束(SDC)；输出：门级网表(.V)、时序报告。工具：Design Compiler, Genus。（必考）
4. 静态时序分析 STA： 在所有条件下检查时序是否满足，注意这里是初步的，后面布局不布线会精确分析。输入：网表、约束(SDC)、 parasitics (SPEF)；工具：PrimeTime, Tempus。（必考）
   1. 数据到达时间 = 发射沿 + 发射时钟路径延迟 + 组合逻辑延迟
   2. 时钟到达时间 = 捕获沿 + 捕获时钟路径延迟
   3. 建立时间违反后果： 数据来得太慢，寄存器无法在时钟沿正确捕获数据。
   4. 数据变化太快，新数据冲掉了本该被捕获的旧数据
   5. 时钟偏斜Skew：同一时钟源到达不同寄存器时钟端的时间差。Skew = T_clk2 - T_clk1
   6. 时钟抖动Jitter：时钟边沿与其理想位置的偏差。是时钟源本身的特性，随时间随机变化。
   7. 时钟域交叉CDC： 数据从一个时钟域（如ClkA）的寄存器，传送到另一个时钟域（如ClkB）的寄存器。
   8. 
5. 形式验证： 比较综合后网表与原始RTL是否逻辑等价。工具：Formality, Conformal
   1. 不使用测试向量，而是通过数学推理和形式证明来检查设计是否满足某些属性。
   2. 理论上可以遍历所有可能的输入状态，发现角落错误
   3. 无需测试向量： 节省了编写大量测试用例的时间
   4. 需要编写属性： 需要工程师用属性描述语言（如SVA）来精确描述设计应有的行为
   5.  对于大规模设计，状态空间过大，可能导致无法完成证明

## 后端设计

6. 布局规划 (Floorplanning)需要规划出标准单元的放置区域（Core Area）以及宏模块（Macro，如RAM、PLL等）的精确位置
7. 布局 (Placement)
目标：将综合后的网表中的所有标准单元放置在布局规划确定的Core Area内。输入：网表、工艺文件(LEF)、布局布线库(LEF, LIB)、约束(SDC)；输出：所有单元具有合法物理位置的版图GDSII。工具：Innovus, ICC2

全局布局（Global Placement）：大致确定每个单元的位置，以优化时序和布线拥塞为目标，但单元之间可能有重叠。

详细布局（Detailed Placement）： legalize单元位置，消除重叠，使其符合制造网格和行（Row）的要求。


8. 时钟树综合 (CTS, Clock Tree Synthesis)
目标：构建一个低偏差（Skew）、低延迟的时钟分布网络。

内容：时钟信号需要驱动芯片上所有的时序单元（触发器），负载巨大。CTS工具通过插入多级缓冲器（Buffer）来构建一个树状结构，确保时钟信号尽可能同时到达所有触发器。

输出：完整的时钟网络。

9. 布线 (Routing)
目标：按照逻辑连接关系，用金属线连接所有单元。

内容：

全局布线（Global Routing）：规划布线路径，分配布线资源，避免拥塞。

详细布线（Detailed Routing）：在遵守设计规则（DRC）的前提下，完成金属线的具体走线。

输出：所有逻辑连接都被金属线实现的物理版图。

- 拥塞： 局部区域布线需求超过可用布线轨道数量，导致无法布通或时序恶化。

- 串扰： 相邻信号线之间的电容耦合导致噪声，可能影响信号完整性和时序。

10. 寄生参数提取 (Parasitic Extraction)
目标：从布完线的版图中提取出金属连线的电阻（R）和电容（C）等寄生参数。

内容：布线完成后，导线本身会带来电阻和线间电容，这些寄生效应会显著影响信号的时序和完整性。提取工具会生成一个包含寄生信息的标准文件（如SPEF）。

输出：带寄生参数的网表。

11. 版图后验证 及签核 (Post-Layout Verification)
这是流片前的最后一道关卡，至关重要。

- 静态时序分析（STA）：使用提取出的精确寄生参数（带延迟信息）再进行一次STA。这是最接近实际的时序验证，必须通过。输入：门级网表、 寄生参数文件 (SPEF)、约束(SDC)

- 形式验证（Formal Verification）：对比布局后的网表与综合后的网表，确保逻辑功能在物理实现后没有改变。

- 时序仿真（后仿真）

- 物理验证（Physical Verification）：DRC (Design Rule Check)：检查版图是否符合晶圆厂的制造工艺规则（如线宽、间距等）。LVS (Layout vs. Schematic)：检查物理版图是否与门级网表在电气连接上完全一致。工具： calibre

- 电学规则检查（ERC）：检查电路中的电学错误，如短路、开路、浮空节点等。

- 功耗完整性（IR Drop）和信号完整性（SI）分析：检查电源网络是否稳健，信号是否受到串扰等干扰。

12. 流片数据生成 (Tape-out)
目标：生成交付给晶圆厂（Foundry）进行制造的最终数据。

内容：将最终通过的版图数据转换为晶圆厂要求的格式，通常是GDSII（一种二进制版图数据格式）。

输出：GDSII文件。这就是“从RTL到GDSII”流程的最终产出。


## 基本概念

### 时序
1. 建立时间：在时钟有效边沿（上升沿或下降沿）到来之前，数据输入端（D）的数据必须保持稳定的最小时间。修复：降低组合逻辑延迟（优化逻辑、插入寄存器流水线）、提高时钟周期（降低频率）。
2. 保持时间：在时钟有效边沿到来之后，数据输入端（D）的数据必须继续保持稳定的最小时间。修复：增加数据路径的延迟（插入buffer），缩短时钟路径的延迟（时钟树综合时平衡）。核心关系：建立时间关乎一个时钟周期内的数据稳定性，而保持时间关乎相邻两个时钟周期之间的数据稳定性。

3. SDC文件：包含时钟定义、输入输出延迟等。SDC文件就是工程师写给EDA工具的“设计任务书”，告诉工具这个芯片要跑多快（时钟），信号从哪里来到哪里去（延时），哪些地方不用管（异常）移动负载

4. 低功耗技术：时钟门控、电源门控。
5. SDC文件： 包含时钟定义、时序异常（false path, multicycle path）、输入输出延迟等。
6. 时钟树：

### 可测试性设计
5. DFT可测试性设计：扫描链(Scan Chain)的作用：将时序单元连接成移位寄存器，用于测试制造缺陷。扫描链就像给芯片内部装上了一串“监控探头”（扫描触发器），测试时可以把内部状态一个个读出来检查，从而发现生产线上的瑕疵品
   1. 正常模式： 寄存器作为普通触发器工作。
   2. 扫描模式： 寄存器被连接成一个移位寄存器。
   3. 测试过程： (a) 切换到扫描模式，将测试向量串行移入扫描链；(b) 切换到正常模式，捕获一个时钟周期的响应；(c) 再切换回扫描模式，将捕获的响应串行移出，与期望值比较。
6. 内建自测试： 用于存储器测试的MBIST和用于逻辑测试的LBIST。
 

## 考察形式：

填空题： “逻辑综合的输入文件包括______、和。” (答案：RTL代码, 工艺库, 约束文件)

选择题： “以下哪个工具主要用于静态时序分析？A. VCS B. PrimeTime C. Design Compiler D. Calibre” (答案：B)

## 设计方法学

###  低功耗设计：

1. 动态功耗：电路翻转（0->1, 1->0）时对负载电容充放电产生的功耗。这是传统设计中功耗的主要来源
2. 静态功耗： 晶体管漏电流（即使关闭时也有微小电流）产生的功耗。在先进工艺（如28nm以下）中，静态功耗占比急剧上升。
3. 短路功耗： 晶体管在翻转过程中短暂处于导通状态产生的内部电流功耗，通常占比很小。

时钟动，电源静，多电压MVDD多目标，动态电压频率缩放DVFS

高阈值电压降低静态功耗

凡是和开关/翻转（Clock, Switching）相关的，多半是动态功耗优化。

凡是和漏电/关断（Power Gating, Vt）相关的，多半是静态功耗优化。

DVFS/MVDD 通过降低电压，能同时大幅降低动态功耗（V^2）和静态功耗。





技术： 多电压域（Multi-Vdd）、电源门控（Power Gating）、时钟门控（Clock Gating）、动态电压频率缩放（DVFS）。

标准： UPF (Unified Power Format) 或 CPF (Common Power Format) 用于描述功耗意图。

考察形式： 选择题，如“以下哪种技术属于动态功耗优化？A. 电源门控 B. 时钟门控 C. 使用高Vt单元” (答案：B，时钟门控减少翻转活性)




# EDA 算法与架构

## EDA算法

### 逻辑综合：
布尔逻辑优化： 根据布尔代数的定理来简化逻辑表达式（代数法，卡诺图，Espersso

两级逻辑优化： 卡诺图、Quine-McCluskey算法。

多级逻辑优化： 技术映射（将布尔网络映射到标准单元库, 必须用库里的单元组合实现逻辑功能）。

### 物理设计：

划分： 将电路分成更小的子集。

布局： 力导向算法（模拟弹簧质点系统）、模拟退火（全局优化算法）。
-  力导向布局：速度快，易于实现，能快速得到一个较好的初始布局， 只是对线长的粗略估计，没有考虑实际的布线阻塞，最终结果可能不是最优的。通常用于全局布局的初始阶段
-  模拟退火布局： 速度慢，精度高，对线长的精确估计，考虑实际的布线阻塞，最终结果可能不是最优的。通常用于全局布局的优化阶段

布线： 全局布线（生成布线路径）、详细布线（完成金属连接），常用 A*搜索算法 寻找两点间最短路径。Lee‘s Algorithm。
- Lee's Algorithm 详细布线算法，用于为两个点寻找一条最短路径。它能保证找到一条路径（如果存在的话），内存和计算开销巨大（需要存储和遍历大量网格），只适用于小范围的布线或关键线网的布线。它是选择题高频考点，必须掌握其核心思想是“波传播”和“回溯”
- 通道布线：问题相对规则化，有很多高效算法（如左端算法）来解决。它是早期半自动设计中的一种重要布线模式。
- A*搜索算法： 搜索算法，用于为两个点寻找一条最短路径。它是一种广度优先搜索算法，用于解决最短路径问题。

### 时序分析：

静态时序分析： 计算到达时间/要求时间、时序路径（建立时间检查、保持时间检查）、时序图遍历。

考察形式： 填空题：“布局阶段常用的两种优化算法是______和______。” (答案：力导向算法，模拟退火)；选择题：“STA的全称是？” (答案：Static Timing Analysis)

## 核心架构

数据模型： 网表（Netlist）是EDA工具的核心数据结构，通常用图表示（节点是单元，边是线网）。

数据库： 高效的内存数据管理是EDA工具性能的关键。


# 数据结构

树：二叉树的前序、中序、后序遍历（很可能考顺序）；二叉搜索树的定义（左<根<右）。

图：邻接矩阵和邻接表的区别和适用场景；广度优先搜索(BFS) 和深度优先搜索(DFS) 的基本思想。

## 树
前中后描述的是根节点的顺序，左一定在右前面
前：跟左右
中：左跟右
后：左右跟

## 图

邻接矩阵：边稠密（E≈V²）、需频繁查边，
邻接表：边稀疏（E≪V²）、需遍历邻接点


## 算法
### 排序
1. 冒泡排序： 遍历数组，两两比较，将较大的数交换到后面。
2. 快速排序： 递归，分治，左右指针。选基准，分两段
3. 归并排序： 稳定拆半
快排“快在原地把活干”，归并“稳在合并不翻脸”。

# C++考察

C++：

面向对象：封装、继承、多态的概念。重载(overload) 和重写(override) 的区别。

内存管理：new/delete和malloc/free的区别。
C++中new是运算符，malloc是函数，前者会调用构造函数，后者不会。这是一个经典考点。

STL：vector, list, map (unordered_map) 的基本特性和使用场景（问哪个查找快，用map）。

Python：

基础语法：列表推导式、字典、lambda函数。

特性：动态语言、缩进、GIL锁等概念性选择题。

## 面向对象
1. 封装：隐藏实现细节，只提供接口。
2. 继承：子类（派生类）继承父类（基类）的属性和方法，并添加新的属性和方法，也可以修改父类的方法
3. 多态：同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。接口统一，动态绑定：程序在运行时（而非编译时）才能确定实际调用的方法是哪个子类的方法，使用者只需面向父类编程
4. 重载： 同一个函数名，不同的参数列表，编译器会自动选择最匹配的函数，可以修改返回类型
5. 重写： 子类重写父类的方法，并添加新的功能，不能修改返回类型


## 内存管理
1. new 无需指定内存大小，编译器自行计算， malloc 需要指定内存大小
2. new/delete 是功能完整的对象管理者：它们不仅负责内存的分配和释放，更重要的是会自动调用构造函数和析构函数来完成对象的初始化和清理工作.malloc/free 是纯粹的内存管理者：它们只负责分配和释放一块原始的内存空间，对里面的内容（对象）不闻不问

Tips:
1. 析构函数：释放资源，自动调用，不能重载，每个类只有一个
2. 构造函数

new 做了两件事：1) 分配内存 (malloc 的工作) 2) 调用构造函数。

delete 也做了两件事：1) 调用析构函数 2) 释放内存 (free 的工作)。

malloc 和 free 只负责内存的分配和释放，对构造函数和析构函数一无所知。

## STL库的基本使用（vector, list, map）

1. vector	动态数组	一段连续的内存空间
2. list	链表	一段非连续的内存空间，通过指针连接
3. map	红黑树	一颗平衡的二叉搜索树
4. unordered_map	哈希表	数组+链表/红黑树（解决哈希冲突）	

unordered_map 的查找平均最快，为 O(1)。而 map 的查找是 O(log n)。如果不需要元素有序，应优先选择 unordered_map。


## 高性能
### 并行计算

进程是资源分配的单位（操作系统为它划分内存、文件、权限等）。
线程是执行的单位（CPU 调度时只看线程，进程不直接运行）。

### 异构计算
### 分布式系统


## 编译
编译：预处理->编译->汇编->链接四个阶段。

1. 预处理：预处理程序将源代码中的宏定义、包含文件、注释、空行等替换为实际内容，并生成一个临时文件。输出： 一个纯粹的、经过“清洗”和“扩展”的文本文件，通常以 .i 或 .ii 为扩展名。这个文件不再包含任何预处理指令
2. 编译：输入： 预处理后生成的 .i 文件。处理者： 编译器（如 cc1, gcc, clang）。编译器会进行词法分析、语法分析、语义分析、优化等一系列复杂操作，将高级语言代码翻译成与硬件平台相关的汇编语言代码，输出： 一个汇编语言文件，通常以 .s 为扩展
3. 汇编：输入： 步骤 2 生成的 .s 文件。处理者： 汇编器（如 as, nasm, yasm）。汇编器将汇编语言代码翻译成机器码，输出： 一个可执行文件，通常以 .o 为扩展
4. 链接：输入： 步骤 3 生成的 .o 文件。处理者： 链接器（如 ld, ld.bfd, ld.gold）。链接器将多个对象文件链接成可执行文件，输出： 一个可执行文件，如 a.out (Linux默认) 或 .exe (Windows)

## Liunx

1. grep 全局搜索正则表达式并打印
2. find 搜索文件 ： “find 路径 [选项] [操作]” 
   1. find . -name "*.log"
   2. find . -type f -size +100M