# 芯片设计全流程
重点知识：你必须像背诵乘法口诀一样熟悉从行为描述到GDSII的每一个步骤，包括每个步骤的输入、输出、目的和主流工具。
主流：自顶向下： 前端从系统设计到门级网表，后端从晶体管到GDSII


## 前端设计

1. RTL设计：HDL描述电路功能，定义寄存器传输级的数据流动以及如何被组合逻辑处理。OUTPUT: RTL代码
   1. 非阻塞赋值：在当前仿真时间步长（time step）的结束时刻统一完成赋值操作。所有右侧表达式的计算是并行的，使用的是该时间步长开始时的原始值
   2. 避免生成锁存器： 在组合逻辑中，如果条件语句（if/case）分支不全，或赋值不完整，会综合出非预期的锁存器。确保所有条件下输出都有明确赋值。
2. 功能验证（前仿）确保RTL代码逻辑正确。工具：VCS, NC-Verilog, ModelSim。OUTPUT: 逻辑验证结果
3. 逻辑综合： 将RTL代码映射到特定工艺库的门级网表。输入：RTL代码、工艺库(.lib)、约束(SDC)；输出：门级网表(.V)、时序报告。工具：Design Compiler, Genus。（必考）
4. 静态时序分析 STA： 在所有条件下检查时序是否满足，注意这里是初步的，后面布局不布线会精确分析。输入：网表、约束(SDC)、 parasitics (SPEF)；工具：PrimeTime, Tempus。（必考）
   1. 数据到达时间 = 发射沿 + 发射时钟路径延迟 + 组合逻辑延迟
   2. 时钟到达时间 = 捕获沿 + 捕获时钟路径延迟
   3. 建立时间违反后果： 数据来得太慢，寄存器无法在时钟沿正确捕获数据。
   4. 数据变化太快，新数据冲掉了本该被捕获的旧数据
   5. 时钟偏斜Skew：同一时钟源到达不同寄存器时钟端的时间差。Skew = T_clk2 - T_clk1
   6. 时钟抖动Jitter：时钟边沿与其理想位置的偏差。是时钟源本身的特性，随时间随机变化。
   7. 时钟域交叉CDC： 数据从一个时钟域（如ClkA）的寄存器，传送到另一个时钟域（如ClkB）的寄存器。
   
5. 形式验证： 比较综合后网表与原始RTL是否逻辑等价。工具：Formality, Conformal
   1. 不使用测试向量，而是通过数学推理和形式证明来检查设计是否满足某些属性。
   2. 理论上可以遍历所有可能的输入状态，发现角落错误
   3. 无需测试向量： 节省了编写大量测试用例的时间
   4. 需要编写属性： 需要工程师用属性描述语言（如SVA）来精确描述设计应有的行为
   5.  对于大规模设计，状态空间过大，可能导致无法完成证明

## 后端设计

6. 布局规划 (Floorplanning)需要规划出标准单元的放置区域（Core Area）以及宏模块（Macro，如RAM、PLL等）的精确位置
7. 布局 (Placement)
目标：将综合后的网表中的所有标准单元放置在布局规划确定的Core Area内。输入：网表、工艺文件(LEF)、布局布线库(LEF, LIB)、约束(SDC)；输出：所有单元具有合法物理位置的版图GDSII。工具：Innovus, ICC2

全局布局（Global Placement）：大致确定每个单元的位置，以优化时序和布线拥塞为目标，但单元之间可能有重叠。

详细布局（Detailed Placement）： legalize单元位置，消除重叠，使其符合制造网格和行（Row）的要求。


8. 时钟树综合 (CTS, Clock Tree Synthesis)
目标：构建一个低偏差（Skew）、低延迟的时钟分布网络。

内容：时钟信号需要驱动芯片上所有的时序单元（触发器），负载巨大。CTS工具通过插入多级缓冲器（Buffer）来构建一个树状结构，确保时钟信号尽可能同时到达所有触发器。

输出：完整的时钟网络。

9. 布线 (Routing)
目标：按照逻辑连接关系，用金属线连接所有单元。

内容：

全局布线（Global Routing）：规划布线路径，分配布线资源，避免拥塞。

详细布线（Detailed Routing）：在遵守设计规则（DRC）的前提下，完成金属线的具体走线。

输出：所有逻辑连接都被金属线实现的物理版图。

- 拥塞： 局部区域布线需求超过可用布线轨道数量，导致无法布通或时序恶化。

- 串扰： 相邻信号线之间的电容耦合导致噪声，可能影响信号完整性和时序。

10. 寄生参数提取 (Parasitic Extraction)
目标：从布完线的版图中提取出金属连线的电阻（R）和电容（C）等寄生参数。

内容：布线完成后，导线本身会带来电阻和线间电容，这些寄生效应会显著影响信号的时序和完整性。提取工具会生成一个包含寄生信息的标准文件（如SPEF）。

输出：带寄生参数的网表。

11. 版图后验证 及签核 (Post-Layout Verification)
这是流片前的最后一道关卡，至关重要。

- 静态时序分析（STA）：使用提取出的精确寄生参数（带延迟信息）再进行一次STA。这是最接近实际的时序验证，必须通过,确保没有建立时间和保持时间违例。输入：门级网表、 寄生参数文件 (SPEF)、约束(SDC)

- 形式验证（Formal Verification）：对比布局后的网表与综合后的网表，确保逻辑功能在物理实现后没有改变。

- 时序仿真（后仿真）: 动态仿真:动态仿真需要测试向量且可能不全面

- 物理验证（Physical Verification）：DRC (Design Rule Check)：检查版图是否符合晶圆厂的制造工艺规则（如线宽、间距等）。LVS (Layout vs. Schematic)：检查物理版图是否与门级网表在电气连接上完全一致。工具： calibre, PVS

- 电学规则检查（ERC）：检查电路中的电学错误，如短路、开路、浮空节点等。

- 功耗完整性（IR Drop）和信号完整性（SI）分析：检查电源网络是否稳健，信号是否受到串扰等干扰。

12. 流片数据生成 (Tape-out)
目标：生成交付给晶圆厂（Foundry）进行制造的最终数据。

内容：将最终通过的版图数据转换为晶圆厂要求的格式，通常是GDSII（一种二进制版图数据格式）。

输出：GDSII文件。这就是“从RTL到GDSII”流程的最终产出。


## 基本概念

### 时序
1. 建立时间：在时钟有效边沿（上升沿或下降沿）到来之前，数据输入端（D）的数据必须保持稳定的最小时间。修复：降低组合逻辑延迟（优化逻辑、插入寄存器流水线）、提高时钟周期（降低频率）,、再时钟路径上加缓冲器（buffer），让时钟晚到来(注意不是数据路径)。
2. 保持时间：在时钟有效边沿到来之后，数据输入端（D）的数据必须继续保持稳定的最小时间。修复：增加数据路径的延迟（插入buffer），缩短时钟路径的延迟（时钟树综合时平衡, 让时钟更早到来）。核心关系：建立时间关乎一个时钟周期内的数据稳定性，而保持时间关乎相邻两个时钟周期之间的数据稳定性。

3. SDC文件：包含时钟定义、输入输出延迟等。SDC文件就是工程师写给EDA工具的“设计任务书”，告诉工具这个芯片要跑多快（时钟），信号从哪里来到哪里去（延时），哪些地方不用管（异常）移动负载

4. 低功耗技术：时钟门控、电源门控。
5. SDC文件： 包含时钟定义、时序异常（false path, multicycle path）、输入输出延迟等。
6. 时钟树：

时序电路只使用非阻塞型语句

阻塞赋值 (=)： 顺序执行，好比C语言赋值。通常用于组合逻辑。

非阻塞赋值 (<=)： 并发执行，所有赋值在块结束时同时发生。必须用于描述时序逻辑（寄存器）

时序逻辑电路不仅与输入有关，还与原来的状态有关
在异步FIFO 设计中，满信号由写时钟产生，空信号由读时钟产生. 

时钟频率是整倍数，并且相互之间的相位是固定而且相差可预知的，才可以称得上是同步时钟。


39、下列哪些必须是在Post‐Layout 时序仿真的?（AC）
A.Post‐Layout 网表
B.综合网表
C.标准延时格式文件
D.RTL 代码

11、从静态时序分析的角度考虑，时钟的时序特性主要是指那三点?( )
A. Jter、Duty Cyde Distotion、max frequency
B. Jitter、Skew、transition
C. Jitter、Skew、Duty Cycle Distortion
D. Skew、transition、max ftrequency
解析：
从静态时序分析的角度考虑，时钟的时序特性主要是指以下三点：
Jitter：时钟信号的抖动，是时钟信号与其本地时钟源的时间偏差的随机变化。时钟抖动可能
影响到时序分析的准确性，因为它会导致时钟信号的上升沿和下降沿出现突然的偏移。
Skew：时钟信号的相对延迟或提前量，是时钟信号到达不同部件的时间差异。
Duty Cycle Distortion：指时钟信号的占空比的变化，它可以由时钟信号的上升沿和下降沿的
偏移和不对称性引起。Jitter、Skew 和 Duty Cycle Distortion 都会影响时序的准确性和带宽限
制，因此在时序分析和设计中需要加以考虑和处理


### 可测试性设计
5. DFT可测试性设计：扫描链(Scan Chain)的作用：将时序单元连接成移位寄存器，用于测试制造缺陷。扫描链就像给芯片内部装上了一串“监控探头”（扫描触发器），测试时可以把内部状态一个个读出来检查，从而发现生产线上的瑕疵品
   1. 正常模式： 寄存器作为普通触发器工作。
   2. 扫描模式： 寄存器被连接成一个移位寄存器。
   3. 测试过程： (a) 切换到扫描模式，将测试向量串行移入扫描链；(b) 切换到正常模式，捕获一个时钟周期的响应；(c) 再切换回扫描模式，将捕获的响应串行移出，与期望值比较。
6. 内建自测试： 用于存储器测试的MBIST和用于逻辑测试的LBIST。
 

### 验证
当功能覆盖率达到100%: 某些令人关注的情况已经得到测试覆盖
条件覆盖率没打到 100 %，不能推出验证一定不完备；反过来，100 % 条件覆盖也不能保证验证已完备。
业界常用的验证方法学有VMM （ Verification Methodology Manual ） 、OVM（OpenVerification Methodology）和UVM（Universal Verification Methodology）；SystemC 和SystemVerilog 不是验证方法学，是语言！

### 测试

2. 黑盒: 直接通过对产品功能定义的解读，完成端到端测试，通过输入导出预期输出，无需了解中间的RTL 代码。
3. 白盒: 是通过对RTL 代码的解读，分解出代码实现过程中可能出的问题，
3. 灰盒: 灰盒测试则介于黑盒和白盒之间，通过定向用例测试一些RTL 内部实现的细节，观察其输出正确性，辅以断言检测



## 考察形式：

填空题： “逻辑综合的输入文件包括______、和。” (答案：RTL代码, 工艺库, 约束文件)

选择题： “以下哪个工具主要用于静态时序分析？A. VCS B. PrimeTime C. Design Compiler D. Calibre” (答案：B)

## 设计方法学

###  低功耗设计：

1. 动态功耗：电路翻转（0->1, 1->0）时对负载电容充放电产生的功耗。这是传统设计中功耗的主要来源
2. 静态功耗： 晶体管漏电流（即使关闭时也有微小电流）产生的功耗。在先进工艺（如28nm以下）中，静态功耗占比急剧上升。
3. 短路功耗： 晶体管在翻转过程中短暂处于导通状态产生的内部电流功耗，通常占比很小。

时钟动，电源静，多电压MVDD多目标，动态电压频率缩放DVFS

高阈值电压降低静态功耗 (在PR 阶段将std‐Vt 的逻辑单元替换为high‐Vt 的逻辑单元主要作用)

凡是和开关/翻转（Clock, Switching）相关的，多半是动态功耗优化。

凡是和漏电/关断（Power Gating, Vt）相关的，多半是静态功耗优化。

DVFS/MVDD 通过降低电压，能同时大幅降低动态功耗（V^2）和静态功耗。


技术： 多电压域（Multi-Vdd）、电源门控（Power Gating）、时钟门控（Clock Gating）、动态电压频率缩放（DVFS）。

标准： UPF (Unified Power Format) 或 CPF (Common Power Format) 用于描述功耗意图。

考察形式： 选择题，如“以下哪种技术属于动态功耗优化？A. 电源门控 B. 时钟门控 C. 使用高Vt单元” (答案：B，时钟门控减少翻转活性)


16、以下低功耗措施中，哪种不是降低电路翻转率的方法?（A）
A 重新安排“if‐else”表达式，可将毛刺或快变化信号移至逻辑锥体的前部
B.采用Gray 码或One‐hot 码作为状态机编码
C.在不进行算术运算的时候，使这些模块的输入保持不变，不让新的操作数进来.
D.减少电路中的glitch
解析：应该将毛刺或快变信号移至逻辑椎体的后部，if‐else 越往后，被选择的概率越小。可以把逻辑延迟大的部分移至逻辑椎体的前部，来减小总的最大延迟，因为在前部意味着最小的选择路径长度。

## Verilog

1. 标识符规则 C、_HW_Er1
2. 对于initial 语句，说法错误的是（d）
a. 在仿真过程中只执行一次
b. 这是一种过程结构语句
c. 在模拟的0 时刻开始
d. 可用于给实际电路赋初值
解析：initial 是不可综合语句，无法变成实际电路。always 语句是循环语句，initial 只执行一次。它们不能嵌套。initial 只执行1 次，always 执行多次; initial 不可以被综合，always 可以综合

Verilog 语言的层次从低到高依次对应: A、门级，寄存器传输级，行为级，功能级，系统级
不可综合语句:initial、fork..join、wait、time、real、display、 forever.

:动态数组通过new ( )函数预先分配存储空间。
：STA 都是针对同步电路的

在Verilog HDL 中，*timescale 编译器指令格式为: timescale AB.其中A 指的是时延单位，
B 指的是时延精度

HDL代码默认是并行执行的。多个always块、assign语句等就像多个硬件模块在同时工作。
assign 语句用于描述组合逻辑，它连续地将一个值驱动到线网（wire）上。只要右边的表达式值发生变化，左边的值立刻更新。它像一个简单的连接或一个没有寄存器的逻辑门。
always 块(或 VHDL中的process )是Verilog中功能最强大的结构之一，用于描述组合逻辑和时序逻辑。它的行为由敏感列表（sensitivity list） 控制。

always @(a or b)： 电平敏感，任何信号变化都会触发。

always @(posedge clk)： 边沿敏感，只在时钟上升沿触发（用于描述时序逻辑，生成寄存器


### 语法
verilog 语言任务可以调用函数和任务,函数可以调用函数。

若class 会被继承，建议在所有的函数/任务中都加上virtual，方便之后拓展；new 函数以及randmize 等除外。

25.systemverilog 中类默认的成员属性是（B）
A.private
B.public
C.automatic
D.local
解析：另外两个分别是protected，local。需注意，public 不是关键词。


## perl

#last 退出循环陈述
#next 到循环的下一个陈述


## 组合&时序逻辑电路
1. 组合逻辑电路输出只与该时刻输⼊有关，与电路原先状态⽆关
2. 状态机必须有一个缺省状态，防止出现未知状态导致系统崩溃，同时也防止状态生成锁存器，就像 case 需要 default 一样




在组合逻辑中，当缺少嵌套if‐else 语句中的最后一个else 子句时，它将推断一个锁存器 latch，因
为寄存器必须记住原来的值。
在一个时序逻辑的always 语句块中，如果最后的else 语句丢失，仍然会继续推断出触发器tigger


### 时序逻辑关系方程
驱动- 输出-状态

### 射频器件
A、收发器B、振荡器C、谐振器
不是: 静电执行器

# EDA 算法与架构

## EDA算法

### 逻辑综合：
转换 translation - 优化 optimization- 映射mapping

布尔逻辑优化： 根据布尔代数的定理来简化逻辑表达式（代数法，卡诺图，Espersso

两级逻辑优化： 卡诺图、Quine-McCluskey算法。

多级逻辑优化： 技术映射（将布尔网络映射到标准单元库, 必须用库里的单元组合实现逻辑功能）。

### 物理设计：

划分： 将电路分成更小的子集。

布局： 力导向算法（模拟弹簧质点系统）、模拟退火（全局优化算法）。
-  力导向布局：速度快，易于实现，能快速得到一个较好的初始布局， 只是对线长的粗略估计，没有考虑实际的布线阻塞，最终结果可能不是最优的。通常用于全局布局的初始阶段
-  模拟退火布局： 速度慢，精度高，对线长的精确估计，考虑实际的布线阻塞，最终结果可能不是最优的。通常用于全局布局的优化阶段

布线： 全局布线（生成布线路径）、详细布线（完成金属连接），常用 A*搜索算法 寻找两点间最短路径。Lee‘s Algorithm。
- Lee's Algorithm 详细布线算法，用于为两个点寻找一条最短路径。它能保证找到一条路径（如果存在的话），内存和计算开销巨大（需要存储和遍历大量网格），只适用于小范围的布线或关键线网的布线。它是选择题高频考点，必须掌握其核心思想是“波传播”和“回溯”
- 通道布线：问题相对规则化，有很多高效算法（如左端算法）来解决。它是早期半自动设计中的一种重要布线模式。
- A*搜索算法： 搜索算法，用于为两个点寻找一条最短路径。它是一种广度优先搜索算法，用于解决最短路径问题。

### 时序分析：

静态时序分析： 计算到达时间/要求时间、时序路径（建立时间检查、保持时间检查）、时序图遍历。
- 时序路径 (Timing Path)： 从一个寄存器时钟端到另一个寄存器数据端的路径。
- 核心思想： 将电路分解为所有可能的时序路径，计算信号沿每条路径传播的延迟，检查信号是否能在下一个时钟事件到来之前稳定下来。

静态时序分析只检查时序(延迟), 不检查功能; 需要输入网表,时序库, 约束, 延迟信息
动态仿真检查时序和功能,  需要输入网表和测试向量, 覆盖率依赖于测试向量的质量

考察形式： 填空题：“布局阶段常用的两种优化算法是______和______。” (答案：力导向算法，模拟退火)；选择题：“STA的全称是？” (答案：Static Timing Analysis)

## 核心架构

数据模型： 网表（Netlist）是EDA工具的核心数据结构，通常用图表示（节点是单元，边是线网）。

数据库： 高效的内存数据管理是EDA工具性能的关键。


# 数据结构

树：二叉树的前序、中序、后序遍历（很可能考顺序）；二叉搜索树的定义（左<根<右）。

图：邻接矩阵和邻接表的区别和适用场景；广度优先搜索(BFS) 和深度优先搜索(DFS) 的基本思想。

## 树
前中后描述的是根节点的顺序，左一定在右前面
前：跟左右
中：左跟右
后：左右跟

## 图

邻接矩阵：边稠密（E≈V²）、需频繁查边，
邻接表：边稀疏（E≪V²）、需遍历邻接点

哈密尔顿路:通过图中所有节点⼀次且恰好⼀次

设G 是有n 个节点m 条边的连通平⾯图，且有k 个⾯，那么k 等于 m-n+2
设完全图G 由5 个顶点构成，则从G 中删去 ( )条边可以得到树。树必须有 n−1=4 条边，因此需删去 10−4=6
设G 是n 阶完全图，请问任意两点之间有多少条路? 1+(n-2)+(n-2)(n-3)+(n-2)(n-3)(n-4)+..+(n-2)..1

图分割: 用于分布式处理

## 算法
### 排序
1. 冒泡排序： 遍历数组，两两比较，将较大的数交换到后面。
2. 快速排序： 递归，分治，左右指针。选基准，分两段, 时间最佳O(N Iog N)
3. 归并排序： 稳定拆半
快排“快在原地把活干”，归并“稳在合并不翻脸”。

# C++考察

C++：

面向对象：封装、继承、多态的概念。重载(overload) 和重写(override) 的区别。

内存管理：new/delete和malloc/free的区别。
C++中new是运算符，malloc是函数，前者会调用构造函数，后者不会。这是一个经典考点。

STL：vector, list, map (unordered_map) 的基本特性和使用场景（问哪个查找快，用map）。

Python：

基础语法：列表推导式、字典、lambda函数。

特性：动态语言、缩进、GIL锁等概念性选择题。

## 面向对象
1. 封装：隐藏实现细节，只提供接口。
2. 继承：子类（派生类）继承父类（基类）的属性和方法，并添加新的属性和方法，也可以修改父类的方法
3. 多态：同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。接口统一，动态绑定：程序在运行时（而非编译时）才能确定实际调用的方法是哪个子类的方法，使用者只需面向父类编程
4. 重载： 同一个函数名，不同的参数列表，编译器会自动选择最匹配的函数，可以修改返回类型
5. 重写： 子类重写父类的方法，并添加新的功能，不能修改返回类型


## 内存管理
1. new 无需指定内存大小，编译器自行计算， malloc 需要指定内存大小
2. new/delete 是功能完整的对象管理者：它们不仅负责内存的分配和释放，更重要的是会自动调用构造函数和析构函数来完成对象的初始化和清理工作.malloc/free 是纯粹的内存管理者：它们只负责分配和释放一块原始的内存空间，对里面的内容（对象）不闻不问

Tips:
1. 析构函数：释放资源，自动调用，不能重载，每个类只有一个
2. 构造函数

new 做了两件事：1) 分配内存 (malloc 的工作) 2) 调用构造函数。

delete 也做了两件事：1) 调用析构函数 2) 释放内存 (free 的工作)。

malloc 和 free 只负责内存的分配和释放，对构造函数和析构函数一无所知。

### 值传递/引用传递的区别

值传递： 用于不希望原始数据被修改的小型数据（如基本数据类型 int, float），或明确需要副本的场景。

引用传递： 极其常用。用于传递大型对象（如整个电路网表Netlist、芯片布局Layout），避免复制的巨大开销。加上const关键字（如 const Netlist &netlist）可以同时保证效率和安全性（禁止函数修改数据）。

## STL库的基本使用（vector, list, map）

1. vector	动态数组	一段连续的内存空间
2. list	链表	一段非连续的内存空间，通过指针连接
3. map	红黑树	一颗平衡的二叉搜索树
4. unordered_map	哈希表	数组+链表/红黑树（解决哈希冲突）	

unordered_map 的查找平均最快，为 O(1)。而 map 的查找是 O(log n)。如果不需要元素有序，应优先选择 unordered_map。


## 高性能
### 并行计算

进程是资源分配的单位（操作系统为它划分内存、文件、权限等）。
线程是执行的单位（CPU 调度时只看线程，进程不直接运行）。

Amdahl 定律:当处理器数量 (N) 不断增加时，加速比的增长会逐渐趋于平缓，最终无限接近上限 \frac{1}{1-P}。例如，如果串行部分占10%（P=0.9），那么无论你用1000个还是10000个处理器，最大加速比也不可能超过10倍


进程与线程的区别、
设计流程：能排序或识别ASIC/VLSI设计的基本步骤：RTL设计 -> 功能仿真 -> 逻辑综合 -> 形式验证 -> 布局布线 -> 时序分析 -> 物理验证。

EDA工具概念：

逻辑综合是什么？输入和输出是什么？（输入：RTL代码、工艺库、约束；输出：门级网表）

静态时序分析（STA）的目的是什么？（在不依赖测试向量的情况下，检查所有路径的时序是否满足要求）

### 通信与同步机制（锁、信号量、条件变量）
Lock: 互斥 (Mutual Exclusion)，保证在任何时刻只有一个线程可以访问共享资源

操作： 在访问共享资源前加锁 (lock)，访问结束后解锁 (unlock)

信号量:  控制访问共享资源的线程数量。它可以允许多个线程同时访问，数量由信号量的初始值决定。

条件变量:  用于线程间的等待和通知。当一个线程需要等待某个条件成立时，它进入睡眠，直到另一个线程改变条件后将其唤醒。它必须与互斥锁结合使用。

### 异构计算
### 分布式系统


## 编译
编译：预处理->编译->汇编->链接四个阶段。

1. 预处理：预处理程序将源代码中的宏定义、包含文件、注释、空行等替换为实际内容，并生成一个临时文件。输出： 一个纯粹的、经过“清洗”和“扩展”的文本文件，通常以 .i 或 .ii 为扩展名。这个文件不再包含任何预处理指令
2. 编译：输入： 预处理后生成的 .i 文件。处理者： 编译器（如 cc1, gcc, clang）。编译器会进行词法分析、语法分析、语义分析、优化等一系列复杂操作，将高级语言代码翻译成与硬件平台相关的汇编语言代码，输出： 一个汇编语言文件，通常以 .s 为扩展
3. 汇编：输入： 步骤 2 生成的 .s 文件。处理者： 汇编器（如 as, nasm, yasm）。汇编器将汇编语言代码翻译成机器码，输出： 一个可执行文件，通常以 .o 为扩展
4. 链接：输入： 步骤 3 生成的 .o 文件。处理者： 链接器（如 ld, ld.bfd, ld.gold）。链接器将多个对象文件链接成可执行文件，输出： 一个可执行文件，如 a.out (Linux默认) 或 .exe (Windows)

## 操作系统
9.计算机执行程序时，在（A）的控制下，逐条从内存中取出指令、分析指令、执行指令。A.控制器

## Liunx

1. grep 全局搜索正则表达式并打印
2. find 搜索文件 ： “find 路径 [选项] [操作]” 
   1. find . -name "*.log"
   2. find . -type f -size +100M

   

因此，总线QoS 的主要目的是同时满足各种应用程序的带宽需求，以提高整个系统的性能、稳定性和可靠性，因此答案为 D. 合理的带宽分配。


11、降低电路翻转率常用方法有:（ ）
A.采用Pipeline 设计:
B.对某种工作模式下空闲模块需要增加时钟关断(Clock Gaing)
C.降低频繁翻转信号的逻辑深度；
解析：
A、B、C 都是降低电路翻转率的常用方法。